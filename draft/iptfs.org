# -*- fill-column: 70 -*-
# This is a comment.
#

This document describes a mechanism to provides for robust traffic
flow security (also referred to as traffic flow confidentiality) for
IP encapsulated traffic. Traffic flow security is provided by
obscuring the size and frequency of IP traffic using a constant sized
and constant send rate encrypted tunnel.

* Introduction

Traffic Analysis ^RFC4301^ is the act of extracting information about
data being sent through a network. While one may directly obscure the
data through the use of encryption ^RFC4303^, the traffic pattern
itself still exposes information due to variations in it's shape and
timing ^AppCrypt8.6^. Hiding the size and frequency of traffic is
referred to as Traffic Flow Confidentiality (TFC) ^RFC4303^

^RFC4303^ provides for limited TFC by allowing for padding to be added
to encrypted IP packets. This method has a few limitations. One
limitation is that the frequency of the data being sent is not
obscured. A second limitation is that only a single IP packet of data
is encapsulated in any encrypted containing packet which wastes a
large amount of available bandwidth.

The IP-TFS solution provides for full TFC without the aforementioned
timing and bandwidth limitations. To do this we use a constant send
IPsec ^RFC4303^ tunnel of fixed-sized encapsulating packets. These
fixed-sized packets are sent at a constant rate and contain
partial, full or multiple IP packets to maximize the bandwidth of the
tunnel.

Additionally IP-TFS provides for dealing with network congestion This
is important when the IP-TFS user is not fully in control of the
IP-TFS tunnel path ^RFC2914^.

* The Algorithm

As mentioned in ^Introduction^ IP-TFS utilizes an IPsec ^RFC4303^
tunnel as it's transport. To provide for full TFC we send fixed sized
encapsulating packets at a constant rate on the tunnel.

The primary input to the algorithm is the requested bandwidth of the
tunnel. From this we must determine the size and rate of the fixed
sized packets we will send on the tunnel.

The fixed-packet-size may either be specified manually or can be
determined optimally through the use of Path MTU discovery ^RFC1191^
and ^RFC8201^.

Given the encapsulating fixed-packet-size and the requested tunnel
bandwidth we determine the correct packet send rate. The packet send
rate is the requested bandwidth divided by the payload size of the
fixed-packet-size encapsulating packet.

** Tunnel Content

As previously mentioned one issue with the TFC padding solution in
^RFC4303^ is the large amount of wasted bandwidth as
only one IP packet can be sent per encapsulating packet. In order to
maximize bandwidth IP-TFS breaks this one-to-one association.

With IP-TFS we fragment and aggregate the inner IP traffic flow into
the encapsulating IP tunnel packets. We only pad the tunnel packets if
there is no data available to be sent at the time of tunnel packet
transmission.

In order to do this we create a new payload data type identified with
a new IP protocol number TBD (see ^IANA Considerations^). This payload
is comprised of a 32 bit header followd by either a partial, a single
or multiple data-blocks.

*** IPsec Payload Format

#+begin_example

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
   +-----------------------------------------------------------------+
 0 |V|          Reserved           |          BlockOffset            |
   +-----------------------------------------------------------------+
 4 |       Data Blocks ...
   +---------------

#+end_example

The BlockOffset value is either zero or some offset into or past the
end of the encapsulating packet. If the value is zero it means that a
data-block immediately follows the header. Conversely if the value is
non-zero it points at the start of the next data block. It can be the
case that the BlockOffset points past the end of the encapsulating
packet. This simply means that the next data-block occurs in a
subsequent encapsulating packet. When the BlockOffset is non-zero
the data immediately following the header belongs to the previous
data-block that is still being re-assembled.

*** Data-Blocks

A data-block is defined by a 4-bit type code followed by the data
block data. The types values have been carefully chosen to coincide
with the IPv4/IPv6 version field values so that no per-data-block type
overhead is required to encapsulate an IP packet.

#+begin_example

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
     +-----------------------------------------------------------------+
   0 | Type  | rest of IPv4, IPv6 or pad.
     +--------

#+end_example

** Modes of operation

The tunnel can operae in 2 modes, a congestion controlled mode and
non-congestion controlled mode.

** Non-Congestion Controlled Mode

The non-congestion controlled mode should only be used where the user
has full administrative control over the path the tunnel will take,
and can therefor guarantee the bandwidth. In this case packet loss
should be signaled to the administrator so that any failures due to a
lack of bandwidth can be corrected.

** Congestion Controlled Mode

With the congestion controlled mode we adapt to network congestion and
downgrade the packet send rate to accommodate. If congestion were
handled in the network on a byte level we might could lower the IPsec
(encap) packet size to adapt; however, as congestion is normally
handled in the network by dropping packets we instead choose to lower
the frequency we send our fixed sized packets. This also minimizes
transport overhead.

The output of the congestion control algorithm SHOULD adjust the
frequency that we send our packets until the congestion is
accommodated. We do not standardize the congestion control algorithm,
although it should conform to ^RFC2914^.

** Congestion Information

In order to support congestion control we send regular reports from
the receiver to the sender indicating the number of packet drops over
during a sequence of packets. These reports can also be sent when in the
non-congestion controlled mode to allow for reporting from the sending
device.

** Keywords

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in BCP
14, ^RFC2119^ ^RFC8174^ when, and only when, they appear in all capitals,
as shown here..

** Concepts and Terminology

This document assumes familiarity with IP security concepts described
in ^RFC4301^.

* Packet and Data Formats
** IPSec
*** Payload Format

#+begin_example

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
   +-----------------------------------------------------------------+
 0 |V|          Reserved           |          BlockOffset            |
   +-----------------------------------------------------------------+
 4 |       Data Blocks ...
   +---------------

#+end_example

    - V :: Version, must be set to zero and dropped if set to 1.
    - Reserved  :: set to 0 ignored on receipt.
    - BlockOffset :: This is the number of bytes before the next
                     IP/IPv6 data block. It can point past the end of
                     the containing packet in which case this packet
                     is the continuation of a preivous one and
                     possibly padding. NOTE: This can point into the
                     next packet and yet the current packet can end
                     with padding. This will happen if there's not
                     enough bytes to start a new inner packet in the
                     current outer packet.
    - Data Blocks :: variable number of bytes that constitute the
                     start or continuation of a previous data block.

 *** Data Block

#+begin_example

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
   +-----------------------------------------------------------------+
 0 | Type  | IPv4, IPv6 or pad.
   +--------

#+end_example

    - Type :: 0x0 for pad, 0x4 for IPv4, 0x6 for IPv6.

**** IPv4 Data Block

#+begin_example

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
   +-----------------------------------------------------------------+
 0 |  0x4  |  IHL  | Type Of Service |         Total Length          |
   +------------------------------------------------------------------
 4 | Rest of inner packet ...
   +

#+end_example

    - Type :: 0x4 for IPv4 (i.e., first nibble of IPv4 packet).
    - Total Length :: Length of the IPv4 inner packet.


**** IPv6 Data Block

#+begin_example

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
   +-----------------------------------------------------------------+
 0 |  0x6  | Traffic Class |              Flow Label                 |
   +------------------------------------------------------------------
 4 |          Total Length         | Rest of inner packet ...
   +--------------------------------

#+end_example

    - Type :: 0x6 for for IPv6 (i.e., first nibble of IPv6 packet).
    - Total Length :: Length of the IPv6 inner packet. unspecified
                      data. For IPv4 and IPv6 the length field must at
                      least be present. It is fine and expected that
                      the packet data may span multiple containing
                      packets. Subsequent packets will have their
                      offset set to point past this IP data.


**** Pad Data Block

#+begin_example

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
   +-----------------------------------------------------------------+
 0 |  0x0  | Padding ...
   +--------

#+end_example

    - Type :: 0x0 for pad
    - Padding :: extends to end of the encapsulating packet.



** IKEv2
***  IKEv2 Informational ACK Notification

#+begin_example

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
     +-----------------------------------------------------------------+
  0  |V|  Reserved   |                     DrpCnt                      |
     +-----------------------------------------------------------------+
  4  |                          Timestamp...
     +-----------------------------------------------------------------+
  8                          ...Timestamp                              |
     +-----------------------------------------------------------------+
  12 |                          AckSeqStart                            |
     +-----------------------------------------------------------------+
  16 |                          AckSeqEnd                              |
     +-----------------------------------------------------------------+

#+end_example

     - V :: Version, must be set to zero and dropped if set to 1.
     - Reserved :: set to 0 ignored on receipt.
     - DrpCnt :: For ack data block this is the drop count between
                 AckSeqStart and AckSeqEnd, If the drops exceed the
                 resolution of the counter then set to the max value.
     - AckSeqStart :: The first SeqNum of the range that this
                      information relates to.
     - AckSeqEnd :: The last SeqNum of the range that this information
                    relates to.
     - Timestamp :: The time when this notification was created and
                    sent.

* IANA Considerations

This document requests a code point be allocated by IANA from
"Assigned Internet Protocol Numbers" for identifying the IP-TFS ESP
payload format.

# ^IANA-PN^ https://www.iana.org/assignments/protocol-numbers

* Security Considerations

Consider that we have made things better.

{{document:
    name ;
    ipr trust200902;
    category std;
    references references.xml;
    title "IP Traffic Flow Security";
    contributor "author:Christian E. Hopps:LabN Consulting, L.L.C.:chopps@chopps.org";
}}

** References
- RFC4301 IPSec 4301 - Traffic Analysis
- RFC4303 IPSec 4303 - Traffic Flow Confidentiality
- RFC8084 Circuit Breakers
- draft-iab-wire-image 3.2 (obscuring timing and sizing information).
